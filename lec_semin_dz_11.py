'''Практическое (домашнее) задание
1. Добавьте ко всем задачам с семинара строки документации и методы вывода 
информации на печать.
2. Создайте класс Матрица. Добавьте методы для:
вывода на печать,
сравнения,
сложения,
*умножения матриц'''

'''Задание сделаю в майские каникулы.
Сейчас высылаю, чтобы опрокинуть дедлайн'''












# '''Создание экземпляра класса, __init__
# За создание экземпляра класса отвечает дандер метод __init__. С ним вы уже
# знакомы по прошлому занятию. Всё дело в том, что это самый частый дандер метод
# в ООП Python'''
# class User:
#     def __init__(self, name: str, equipment: list = None):
#         self.name = name
#         self.equipment = equipment if equipment is not None else []
#         self.life = 3
#         # принтим только в учебных целях, а не для реальных задач
#         print(f'Создал {self} со свойствами:\n'f'{self.name = },\t\
#                 {self.equipment = },\t{self.life= }')

# print('Создаём первый раз')
# u_1 = User('Спенглер')
# print('Создаём второй раз')
# u_2 = User('Венкман', ['протонный ускоритель', 'ловушка'])
# print('Создаём третий раз')
# u_3 = User(equipment=['ловушка', 'прибор ночного видения'], name='Стэнц')




# '''Контроль создания класса через __new__
# Метод __new__ срабатывает раньше __init__ и определяет что должен вернуть
# класс в качестве себя - класса. Рассмотрим вначале общий пример.'''
# class User:
#     def __init__(self, name: str):
#         self.name = name
#         print(f'Создал {self.name = }')

#     def __new__(cls, *args, **kwargs):
#         instance = super().__new__(cls)
#         print(f'Создал класс {cls}')
#         return instance

# print('Создаём первый раз')
# u_1 = User('Спенглер')
# print('Создаём второй раз')
# u_2 = User('Венкман')
# print('Создаём третий раз')
# u_3 = User(name='Стэнц')
# '''Метод __new__ принимает в качестве первого параметра сам себя. Обычно
# используют слово cls — сокращение от class. Так понятно, что мы работаем с
# классом, а не с его экземпляром. Параметры *args, **kwargs нужны для правильной
# работы метода __init__ и попадания в него любых аргументов.'''




# '''Расширение неизменяемых классов
# Один из вариантов использования дандер __new__ — расширение
# функциональности уже имеющихся неизменяемых классов Python. Например мы
# хотим использовать переменную целого типа, которая дополнительно хранит
# присвоенное числу имя.'''
# class NamedInt(int):
#     def __new__(cls, value, name):
#         instance = super().__new__(cls, value)
#         instance.name = name
#         print(f'Создал класс {cls}')
#         return instance

# print('Создаём первый раз')
# a = NamedInt(42, 'Главный ответ жизни, Вселенной и вообще')
# print('Создаём второй раз')
# b = NamedInt(73, 'Лучшее просто число')
# print(f'{a = }\t{a.name = }\t{type(a) = }')
# print(f'{b = }\t{b.name = }\t{type(b) = }')
# c = a + b
# print(f'{c = }\t{type(c) = }')
# '''Параметр value нужен для передачи значения в родительский класс int. Далее к
# целому числу добавляется параметр name с переданным значением. После
# создания объекта он возвращается для присваивания переменной.
# Обратите внимание, что наш класс унаследовал всё, что умеет класс int. Мы смогли
# сложить два числа и получить обычное целое число без свойства name.'''
