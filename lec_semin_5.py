# '''(Из лекции) Для создания генераторного выражения используют круглые скобки, внутри
# которых прописывается логика выражения. В нашем примере циклический перебор
# целых чисел от 97 до 122 и возврат символов из таблицы ASCII с
# соответствующими кодами.'''
# my_gen = (chr(i) for i in range(97, 123))
# print(my_gen)       # <generator object <genexpr> at 0x000001ED58DD7D60>
# print(next(my_gen))
# print(next(my_gen))
# print(next(my_gen))
# for char in my_gen:
#     print(1, char)




# '''(Из лекции) Создаём генератор на основе двух списков x и y. 7 элементов в 
# первом списке и 6 во втором. Всего 13. Генератор считает сумму пар элементов.
# Генератор перебирает все значения списка x и оставляет только нечётные.
# Исключаем 2 и 8, т.е. оставляем 5 из 7 элементов списка для вычисления суммы. 
# В списке y исключаем единицу, т.е. оставляем 5 из 6 элементов. Новичок может
# подумать, что на выходе получим 10 элементов - 5 из x и 5 из y. Но циклы 
# вложены друг в друга, следовательно количество элементов на выходе 5х5=25. '''
# x = [1, 1, 2, 3, 5, 8, 13]
# y = [1, 2, 6, 24, 120, 720]
# print(f'{len(x)=}\t{len(y)=}')
# mult_gen = (i + j for i in x if i % 2 != 0 for j in y if j != 1)
# result = list(mult_gen)
# print(f'{len(result)=}\n{result}')




# '''(Из лекции) Что будет, если генераторное выражение записать не в круглых 
# скобках, а в квадратных? Получим list comprehensions. Другие названия: list 
# comp, генератор списков, списковое включение. И нет, это не генераторное 
# выражение. Генератор списков полностью формирует список с элементами до его 
# присваивания переменной слева от знака равно.'''
# my_listcomp = [chr(i) for i in range(97, 123)]
# print(my_listcomp) # ['a', 'b', 'c', 'd', ..., z]
# for char in my_listcomp:
#     print(">", char)




# '''(Из лекции) Как и генераторные выражения списковые включения поддерживаю 
# несколько циклов и логические проверки для каждого из циклов. Можно 
# воспринимать их как синтаксический сахар, более короткую запись. Например 
# выбираем все чётные числа из исходного списка и складываем их в результирующий.'''
# # Длинный код:
# data = [2, 5, 1, 42, 65, 76, 24, 77]
# res = []
# for item in data:
#     if item % 2 == 0:
#         res.append(item)
# print(f'{res = }')

# # Аналогичное решение, но с использованием синтаксического сахара listcomp:
# data = [2, 5, 1, 42, 65, 76, 24, 77]
# res = [item for item in data if item % 2 == 0]
# print(f'{res = }')

# '''1. Не создаём пустой список в начале.
# 2. Не пишем двоеточия после цикла и логической проверки.
# 3. Исключаем метод append.
# Итого вместо 4 строк кода получаем одну.'''




# '''...Изменим функцию для получения факториала чисел, превратив её в генератор.
# Теперь внутри функции не создаётся пустой список для результатов. В цикле
# вычисляется факториал очередного числа. Далее команда yield возвращает
# значение. Следующий вызов вернёт функцию к циклу for для вычисления
# очередного числа.'''
# def factorial(n):
#     number = 1
#     for i in range(1, n + 1):
#         number *= i
#         yield number

# for i, num in enumerate(factorial(10), start=1):
#     print(f'{i}! = {num}')




# '''Уже знакомые по сегодняшнему уроку функции iter и next могут работать с
# созданными генераторами. Например так:'''
# my_iter = iter(factorial(4))
# print(my_iter)
# print(next(my_iter))
# print(next(my_iter))
# print(next(my_iter))
# print(next(my_iter))
# print(next(my_iter))    # StopIteration














# '''Задание №1
# Пользователь вводит строку из четырёх или более целых чисел, разделённых 
# символом “/”. Сформируйте словарь, где: второе и третье число являются 
# ключами, первое число является значением для первого ключа, четвертое и все 
# возможные последующие числа хранятся в кортеже как значения второго ключа'''

# def slash (s: str) -> dict[int, int]:
#     one, two, three, *other = s.split('/')
#     result ={int(two):int(one), int(three):tuple(map(int, other))}
#     return result

# print(slash(input("Enter string: ")))




# '''Задание №2
# Самостоятельно сохраните в переменной строку текста. Создайте из строки 
# словарь, где ключ - буква, а значение - код буквы.
# Напишите преобразование в одну строку.'''

# string_user = "Текст состоящий из слов!"
# res_dict = {key: ord(key) for key in string_user}

# # # формирование того же самого многострочным способом
# # res = {}
# # for key in string_user:
# #     res[key] = ord(key)

# # print(res)
# print(res_dict)




# '''Задание №3
# Продолжаем развивать задачу 2. Возьмите словарь, который вы получили. 
# Сохраните его в итератор. Далее выведите первые 5 пар ключ-значение, 
# обращаясь к итератору, а не к словарю'''

# my_iter = iter(res_dict.items())
# for i in range(5):
#     print(*next(my_iter))




# '''Задание №4
# ✔ Создайте генератор чётных чисел от нуля до 100.
# ✔ Из последовательности исключите числа, сумма цифр которых равна 8.
# ✔ Решение в одну строку.'''
# gen_chet = (i for i in range(0, 101) if (i // 10) + (i % 10) != 8 and i % 2 == 0)
# print(*gen_chet)




# '''Задание №5
# ✔ Напишите программу, которая выводит на экран числа от 1 до 100.
# ✔ При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz»
# ✔ Вместо чисел, кратных пяти — слово «Buzz».
# ✔ Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz».
# ✔ *Превратите решение в генераторное выражение.'''
# # my_list = []
# # for i in range(1, 101):
# #     if i % 3 == 0 and i % 5 == 0:
# #         my_list.append("FizzBuzz")
# #     elif i%3 == 0:
# #         my_list.append("Fizz")
# #     elif i%5 == 0:
# #         my_list.append("Buzz")
# #     else:
# #         my_list.append(i)

# my_list = ("FizzBuzz" if (i % 3 == 0 and i % 5 == 0) else "Fizz" if (i%3 == 0) else "Buzz" if (i%5 == 0) else i for i in range(1, 101))

# print("qweerrtyy")
# print(*my_list)




# '''Задание №6
# ✔ Выведите в консоль таблицу умножения от 2х2 до 9х10 как на школьной тетрадке.
# ✔ Таблицу создайте в виде однострочного генератора, где каждый элемент 
# генератора — отдельный пример таблицы умножения.
# ✔ Для вывода результата используйте «принт» без перехода на новую строку.'''
# print(*(f'{i: > 2} *{j: > 2} ={i * j: > 2}  ' for i in range (2, 10) for j in range(2, 11)), end= ' ')




# '''Задание №7
# ✔ Создайте функцию-генератор.
# ✔ Функция генерирует N простых чисел, начиная с числа 2.
# ✔ Для проверки числа на простоту используйте правило: «число является 
# простым, если делится нацело только на единицу и на себя».'''
# def gen_num(num: int) -> int:
#     for i in range(2, num + 1):
#         for j in range(2, i):
#             if i % j == 0:
#                 break
#         else:
#             yield i

# # print(gen_num(int(input("Введите число: "))))
# # print(next(gen_num(int(input("Введите число: ")))))
# my_iter_1 = next(gen_num(20))
# print(next(my_iter_1))
# # print(next(gen_num(20)))
# '''Этот пример не совсем завершен на семинаре, и сейчас отрабатывает с ошибкой.
# не удалось реализовать следующее: чтобы он не пачкой выдавал ВСЕ простые числа
# в интервале от 2 до введённого, а возвращал ОДНО СЛЕДУЮЩЕЕ простое число при 
# каждом обращении методом NEXT() - именно так должен работать настоящий 
# генератор. Надо бы здесь немного поиграться, истина где-то рядом. Оператор 
# "yield i" в конце функции обеспечивает такую логику обращений/возвратов, вместо
# "return", запоминает весь локал и при следующем заходе продолжает с прежнего
# места.'''
